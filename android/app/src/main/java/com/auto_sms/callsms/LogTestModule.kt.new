package com.auto_sms.callsms

import android.util.Log
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.Promise
import android.provider.Settings
import android.content.ComponentName
import android.app.NotificationManager
import android.os.Handler
import android.os.Looper
import android.content.Intent
import android.content.IntentFilter
import android.content.BroadcastReceiver
import android.content.Context

/**
 * LogTestModule - A React Native module for testing SMS and RCS logging functionality
 */
class LogTestModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
    private val TAG = "LogTestModule"
    private lateinit var rcsManager: RcsAutoReplyManager
    
    init {
        rcsManager = RcsAutoReplyManager(reactContext)
    }
    
    override fun getName(): String {
        return "LogTestModule"
    }
    
    /**
     * Generate a test SMS message to verify logging functionality
     * This method doesn't actually send an SMS, but triggers the SmsReceiver
     * to simulate an incoming SMS and test the logging
     */
    @ReactMethod
    fun generateTestSms(senderNumber: String, message: String, promise: Promise) {
        Log.e(TAG, "üß™ Generating test SMS for logging from React Native")
        
        try {
            val success = rcsManager.generateTestSmsForLogging(reactApplicationContext, senderNumber, message)
            
            if (success) {
                Log.e(TAG, "‚úÖ Test SMS generated successfully")
                promise.resolve(true)
            } else {
                Log.e(TAG, "‚ùå Failed to generate test SMS")
                promise.reject("ERROR", "Failed to generate test SMS")
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Exception generating test SMS: ${e.message}")
            promise.reject("EXCEPTION", e.message)
        }
    }
    
    /**
     * Output a test SMS log directly to logcat for testing
     * This is useful for testing log filtering without actually sending SMS
     */
    @ReactMethod
    fun logTestSms(senderNumber: String, message: String, promise: Promise) {
        try {
            Log.e("SmsReceiver", "LOGTAG_SMS_DETAILS: üì©üì©üì© SMS MESSAGE DETAILS üì©üì©üì©")
            Log.e("SmsReceiver", "LOGTAG_SMS_DETAILS: ‚ÜòÔ∏è From: $senderNumber")
            Log.e("SmsReceiver", "LOGTAG_SMS_DETAILS: ‚ÜòÔ∏è Message: $message")
            Log.e("SmsReceiver", "LOGTAG_SMS_DETAILS: ‚ÜòÔ∏è Timestamp: ${System.currentTimeMillis()}")
            Log.e("SmsReceiver", "LOGTAG_SMS_DETAILS: ‚ÜòÔ∏è Message Length: ${message.length} characters")
            Log.e("SmsReceiver", "LOGTAG_SMS_DETAILS: ‚ÜòÔ∏è Display Originating Address: $senderNumber")
            Log.e("SmsReceiver", "LOGTAG_SMS_DETAILS: ‚ÜòÔ∏è Message Class: UNKNOWN")
            Log.e("SmsReceiver", "LOGTAG_SMS_DETAILS: ‚ÜòÔ∏è Message ID: 0")
            
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Exception logging test SMS: ${e.message}")
            promise.reject("EXCEPTION", e.message)
        }
    }
    
    /**
     * Output a test RCS log directly to logcat for testing
     * This is useful for testing log filtering without actually receiving RCS
     */
    @ReactMethod
    fun logTestRcs(sender: String, message: String, promise: Promise) {
        try {
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: üì®üì®üì® RCS MESSAGE DETAILS üì®üì®üì®")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Sender: $sender")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Message: $message")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Package: com.google.android.apps.messaging")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Timestamp: ${System.currentTimeMillis()}")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Actions count: 3")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Notification ID: 123")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Notification Key: 0|com.google.android.apps.messaging|123|null|10123")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Is RCS: true")
            Log.e("RcsNotification", "LOGTAG_RCS_DETAILS: ‚ÜòÔ∏è Conversation ID: 0|com.google.android.apps.messaging|123|null|10123")
            
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Exception logging test RCS: ${e.message}")
            promise.reject("EXCEPTION", e.message)
        }
    }
    
    /**
     * Test RCS auto-reply directly by simulating a message through the RcsNotificationListener
     * This bypasses the notification system and helps diagnose issues
     */
    @ReactMethod
    fun testRcsAutoReply(sender: String, message: String, promise: Promise) {
        try {
            Log.e(TAG, "üß™ Testing RCS auto-reply directly")
            Log.e(TAG, "   ‚Ä¢ Sender: $sender")
            Log.e(TAG, "   ‚Ä¢ Message: $message")
            
            // First try the direct approach with RcsAutoReplyManager
            val directReply = rcsManager.processMessage(sender, message)
            
            if (directReply != null) {
                Log.e(TAG, "‚úÖ Direct RcsAutoReplyManager test successful - Reply: $directReply")
                
                // Log this as if it were a real auto-reply for testing
                rcsManager.addLogEntry(sender, message, directReply, true)
                
                promise.resolve(true)
                return
            } else {
                Log.e(TAG, "‚ö†Ô∏è Direct RcsAutoReplyManager test didn't generate a reply")
                // Continue with other methods
            }
            
            // Check if notification listener is enabled in system
            val enabledListeners = Settings.Secure.getString(
                reactApplicationContext.contentResolver,
                "enabled_notification_listeners"
            )
            
            val isEnabled = enabledListeners?.contains(reactApplicationContext.packageName) == true
            
            if (!isEnabled) {
                Log.e(TAG, "‚ùå‚ùå‚ùå CRITICAL: Notification listener is NOT enabled in system settings!")
                Log.e(TAG, "‚ùå‚ùå‚ùå This is why RCS auto-replies are not working!")
                promise.reject("ERROR", "Notification listener not enabled in system settings")
                return
            }
            
            // Alternative approach: Use a broadcast to trigger the service
            Log.e(TAG, "üîÑ Using broadcast method to test RCS auto-reply")
            
            val intent = Intent("com.auto_sms.TEST_RCS_AUTO_REPLY")
            intent.setPackage(reactApplicationContext.packageName)
            intent.putExtra("sender", sender)
            intent.putExtra("message", message)
            
            // Reset RCS state to ensure we can get a reply
            val resetIntent = Intent("com.auto_sms.RESET_RCS_STATE")
            reactApplicationContext.sendBroadcast(resetIntent)
            
            // Send the test broadcast
            reactApplicationContext.sendBroadcast(intent)
            
            // Report success for now, since we can't easily get result
            Log.e(TAG, "‚úÖ Sent test broadcast, check logs for results")
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Exception testing RCS auto-reply: ${e.message}")
            promise.reject("EXCEPTION", e.message)
        }
    }
    
} 