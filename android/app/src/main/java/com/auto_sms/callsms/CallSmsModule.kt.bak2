package com.auto_sms.callsms

import android.Manifest
import android.app.Activity
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.database.Cursor
import android.net.Uri
import android.os.Build
import android.provider.CallLog
import android.provider.Telephony
import android.telephony.SmsManager
import android.telephony.TelephonyManager
import android.util.Log
import androidx.core.content.ContextCompat
import com.facebook.react.bridge.*
import com.facebook.react.modules.core.DeviceEventManagerModule
import java.util.*
import java.text.SimpleDateFormat
import java.util.concurrent.Executors
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.TimeUnit
import java.io.File
import java.io.FileInputStream
import org.apache.pdfbox.pdmodel.PDDocument
import org.apache.pdfbox.text.PDFTextStripper
import org.apache.poi.xwpf.extractor.XWPFWordExtractor
import org.apache.poi.xwpf.usermodel.XWPFDocument
class CallSmsModule(reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {

    private val TAG = "CallSmsModule"
    private var callReceiver: BroadcastReceiver? = null
    private var isMonitoringCalls = false
    private val DEFAULT_MESSAGE = "I am busy, please give me some time, I will contact you."
    private val scheduler: ScheduledExecutorService = Executors.newScheduledThreadPool(1)
    private var lastPhoneState = TelephonyManager.CALL_STATE_IDLE
    private var latestIncomingNumber: String? = null
    private var callStart: Long = 0L
    private var missedCallDetectedAt: Long = 0L
    
    override fun getName(): String {
        return "CallSmsModule"
    }

    private fun hasRequiredPermissions(): Boolean {
        val context = reactApplicationContext
        val readCallLog = ContextCompat.checkSelfPermission(context, Manifest.permission.READ_CALL_LOG) == PackageManager.PERMISSION_GRANTED
        val readPhoneState = ContextCompat.checkSelfPermission(context, Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED
        val sendSms = ContextCompat.checkSelfPermission(context, Manifest.permission.SEND_SMS) == PackageManager.PERMISSION_GRANTED

        return readCallLog && readPhoneState && sendSms
    }

    @ReactMethod
    fun startMonitoringCalls(promise: Promise) {
        if (!hasRequiredPermissions()) {
            val missingPermissions = getMissingPermissions()
            Log.e(TAG, "Missing permissions for call monitoring: $missingPermissions")
            promise.reject(
                "PERMISSIONS_DENIED", 
                "Missing permissions for call monitoring. Please grant all required permissions (Call Log, Phone State, SMS) in the Permissions screen."
            )
            return
        }

        if (isMonitoringCalls) {
            promise.resolve(true)
            return
        }

        try {
            // Reset call state tracking variables to prevent false positives
            lastPhoneState = TelephonyManager.CALL_STATE_IDLE
            latestIncomingNumber = null
            callStart = 0L
            missedCallDetectedAt = System.currentTimeMillis()
            
            // Start our foreground service for persistent monitoring
            val serviceIntent = Intent(reactApplicationContext, CallLogCheckService::class.java)
            
            try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    reactApplicationContext.startForegroundService(serviceIntent)
                } else {
                    reactApplicationContext.startService(serviceIntent)
                }
                Log.d(TAG, "CallLogCheckService started successfully")
            } catch (e: Exception) {
                Log.e(TAG, "Error starting service: ${e.message}", e)
                // Continue with receiver registration even if service start fails
            }
            
            // Register broadcast receiver for immediate response
            val intentFilter = IntentFilter()
            intentFilter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED)
            intentFilter.addAction("android.provider.Telephony.SMS_DELIVERED")
            intentFilter.addAction("android.provider.Telephony.SMS_SENT")
            
            if (callReceiver == null) {
                callReceiver = object : BroadcastReceiver() {
                    override fun onReceive(context: Context, intent: Intent) {
                        if (intent.action == TelephonyManager.ACTION_PHONE_STATE_CHANGED) {
                            handleCallStateChanged(intent)
                        } else if (intent.action == "android.provider.Telephony.SMS_DELIVERED") {
                            handleSmsDelivered(intent)
                        } else if (intent.action == "android.provider.Telephony.SMS_SENT") {
                            handleSmsSent(intent)
                        }
                    }
                }
            }
            
            reactApplicationContext.registerReceiver(callReceiver, intentFilter)
            isMonitoringCalls = true
            
            // Register SMS receiver for AI responses
            registerSmsReceiver()
            
            // Save monitoring state to SharedPreferences
            saveMonitoringStatus(true)
            
            promise.resolve(true)
            
        } catch (e: Exception) {
            Log.e(TAG, "Error starting call monitoring: ${e.message}")
            promise.reject("START_MONITORING_ERROR", "Failed to start monitoring calls: ${e.message}")
        }
    }

    @ReactMethod
    fun stopMonitoringCalls(promise: Promise) {
        if (!isMonitoringCalls) {
            promise.resolve(true)
            return
        }

        try {
            // Unregister receiver
            callReceiver?.let {
                try {
                    reactApplicationContext.unregisterReceiver(it)
                } catch (e: Exception) {
                    Log.e(TAG, "Error unregistering receiver: ${e.message}")
                }
                callReceiver = null
            }
            
            // Stop the service
            val serviceIntent = Intent(reactApplicationContext, CallLogCheckService::class.java)
            reactApplicationContext.stopService(serviceIntent)
            
            isMonitoringCalls = false
            
            // Save monitoring state to SharedPreferences
            saveMonitoringStatus(false)
            
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "Error stopping call monitoring: ${e.message}")
            promise.reject("STOP_MONITORING_ERROR", "Failed to stop monitoring calls: ${e.message}")
        }
    }
    
    /**
     * Save the monitoring status to SharedPreferences
     */
    private fun saveMonitoringStatus(isMonitoring: Boolean) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            sharedPrefs.edit().putBoolean("isMonitoringActive", isMonitoring).apply()
        } catch (e: Exception) {
            Log.e(TAG, "Error saving monitoring status: ${e.message}")
        }
    }
    
    @ReactMethod
    fun setAutoSmsEnabled(enabled: Boolean, promise: Promise) {
        try {
            // Save setting to SharedPreferences for use when app is killed
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            sharedPrefs.edit().putBoolean("@AutoSMS:Enabled", enabled).apply()
            
            if (enabled) {
                if (hasRequiredPermissions()) {
                    startMonitoringCalls(promise)
                } else {
                    promise.resolve(false)
                }
            } else {
                stopMonitoringCalls(promise)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error setting auto SMS enabled: ${e.message}")
            promise.reject("SET_AUTO_SMS_ERROR", "Failed to set auto SMS enabled: ${e.message}")
        }
    }
    
    @ReactMethod
    fun isAutoSmsEnabled(promise: Promise) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            val enabled = sharedPrefs.getBoolean("@AutoSMS:Enabled", true)
            promise.resolve(enabled)
                } catch (e: Exception) {
            Log.e(TAG, "Error getting auto SMS enabled: ${e.message}")
            promise.reject("GET_AUTO_SMS_ERROR", "Failed to get auto SMS enabled: ${e.message}")
        }
    }

    private fun handleCallStateChanged(intent: Intent) {
        val stateStr = intent.getStringExtra(TelephonyManager.EXTRA_STATE)
        val phoneNumber = intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER)
        
        when (stateStr) {
            TelephonyManager.EXTRA_STATE_RINGING -> {
                if (phoneNumber != null) {
                    Log.d(TAG, "Incoming call from: $phoneNumber")
                    latestIncomingNumber = phoneNumber
                    callStart = System.currentTimeMillis()
                    lastPhoneState = TelephonyManager.CALL_STATE_RINGING
                }
            }
            TelephonyManager.EXTRA_STATE_OFFHOOK -> {
                lastPhoneState = TelephonyManager.CALL_STATE_OFFHOOK
            }
            TelephonyManager.EXTRA_STATE_IDLE -> {
                if (lastPhoneState == TelephonyManager.CALL_STATE_RINGING && latestIncomingNumber != null && callStart > 0) {
                    // This indicates a missed call
                    val missedCallDuration = System.currentTimeMillis() - callStart
                    Log.d(TAG, "Missed call detected from: $latestIncomingNumber, duration: $missedCallDuration ms")
                    
                    // For reliability, let's check the call log a bit later to confirm it was missed
                    missedCallDetectedAt = System.currentTimeMillis()
                    sendSmsForMissedCall(latestIncomingNumber!!)
                }
                lastPhoneState = TelephonyManager.CALL_STATE_IDLE
            }
        }
    }

    private fun startCheckingMissedCalls() {
        // Check call log every minute in case we missed the broadcast
        scheduler.scheduleAtFixedRate({
            checkForRecentMissedCalls()
        }, 1, 1, TimeUnit.MINUTES)
    }

    private fun checkForRecentMissedCalls() {
        if (!hasRequiredPermissions()) {
            return
        }

        try {
            val projection = arrayOf(
                CallLog.Calls.NUMBER,
                CallLog.Calls.TYPE,
                CallLog.Calls.DATE
            )
            
            val selection = "${CallLog.Calls.TYPE} = ${CallLog.Calls.MISSED_TYPE}"
            val sortOrder = "${CallLog.Calls.DATE} DESC"
            
            val uri = CallLog.Calls.CONTENT_URI
            val cursor = reactApplicationContext.contentResolver.query(
                uri,
                projection,
                selection,
                null,
                sortOrder
            )
            
            cursor?.use {
                if (it.moveToFirst()) {
                    val numberIndex = it.getColumnIndex(CallLog.Calls.NUMBER)
                    val dateIndex = it.getColumnIndex(CallLog.Calls.DATE)
                    
                    val number = it.getString(numberIndex)
                    val date = it.getLong(dateIndex)
                    
                    // Only consider missed calls from the last 5 minutes
                    val fiveMinutesAgo = System.currentTimeMillis() - 5 * 60 * 1000
                    
                    // Only process missed calls that:
                    // 1. Are recent (within last 5 minutes)
                    // 2. Happened after we started monitoring (missedCallDetectedAt is set when monitoring starts)
                    // 3. Are newer than any missed calls we've already processed
                    if (date > fiveMinutesAgo && date > missedCallDetectedAt && missedCallDetectedAt > 0) {
                        Log.d(TAG, "Found recent missed call from call log: $number at $date")
                        // Send SMS for this missed call
                        sendSmsForMissedCall(number)
                    } else {
                        Log.d(TAG, "Skipping missed call processing: call at $date, monitored since $missedCallDetectedAt")
                    }
                }
            }
                } catch (e: Exception) {
            Log.e(TAG, "Error checking call log: ${e.message}", e)
        }
    }

    @ReactMethod
    fun sendSms(phoneNumber: String, message: String, promise: Promise) {
        if (!hasRequiredPermissions()) {
            val missingPermissions = getMissingPermissions()
            Log.e(TAG, "Missing permissions for sending SMS: $missingPermissions")
            promise.reject(
                "PERMISSIONS_DENIED", 
                "Cannot send SMS: Missing required permissions. Please grant all permissions first."
            )
            return
        }

        try {
            val smsMessage = if (message.isEmpty()) DEFAULT_MESSAGE else message
            val smsManager = SmsManager.getDefault()
            
            // Split message if it's too long
            val parts = smsManager.divideMessage(smsMessage)
            
            val sentIntent = Intent("android.provider.Telephony.SMS_SENT")
            
            // Add FLAG_IMMUTABLE for Android 12+ compatibility
            val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            } else {
                PendingIntent.FLAG_UPDATE_CURRENT
            }
            val sentPI = PendingIntent.getBroadcast(reactApplicationContext, 0, sentIntent, pendingIntentFlags)
            
            // Send SMS
            if (parts.size > 1) {
                // Create PendingIntent array for multipart SMS
                val sentIntents = ArrayList<PendingIntent>().apply {
                    repeat(parts.size) { i ->
                        add(PendingIntent.getBroadcast(reactApplicationContext, i, sentIntent, pendingIntentFlags))
                    }
                }
                smsManager.sendMultipartTextMessage(phoneNumber, null, parts, sentIntents, null)
            } else {
                smsManager.sendTextMessage(phoneNumber, null, smsMessage, sentPI, null)
            }
            
            // Create data for event
            val eventData = Arguments.createMap().apply {
                putString("phoneNumber", phoneNumber)
                putString("message", smsMessage)
                putString("status", "SENT")
                putDouble("timestamp", System.currentTimeMillis().toDouble())
            }
            
            // Emit event
            sendEvent("onSmsSent", eventData)
            
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "Error sending SMS: ${e.message}", e)
            
            // Create data for event
            val eventData = Arguments.createMap().apply {
                putString("phoneNumber", phoneNumber)
                putString("message", message)
                putString("status", "FAILED")
                putString("error", e.message ?: "Unknown error")
                putDouble("timestamp", System.currentTimeMillis().toDouble())
            }
            
            // Emit event
            sendEvent("onSmsError", eventData)
            
            promise.reject("SEND_SMS_ERROR", "Failed to send SMS: ${e.message}")
        }
    }

    private fun sendSmsForMissedCall(phoneNumber: String) {
        // Only proceed if this is a genuine missed call (not during initialization)
        // Check if the missed call detection happened during normal operation
        if (lastPhoneState != TelephonyManager.CALL_STATE_RINGING || callStart == 0L) {
            Log.d(TAG, "Skipping auto-SMS for $phoneNumber - not a confirmed missed call")
            return
        }
        
        // We'll use the default message for missed calls
        try {
            val smsMessage = DEFAULT_MESSAGE
            val smsManager = SmsManager.getDefault()
            
            // Split message if it's too long
            val parts = smsManager.divideMessage(smsMessage)
            
            // Add FLAG_IMMUTABLE for Android 12+ compatibility
            val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            } else {
                PendingIntent.FLAG_UPDATE_CURRENT
            }
            
            // Prepare PendingIntent for SMS
            val sentIntent = Intent("android.provider.Telephony.SMS_SENT")
            val sentPI = PendingIntent.getBroadcast(reactApplicationContext, 0, sentIntent, pendingIntentFlags)
            
            Log.d(TAG, "Sending SMS to $phoneNumber for a missed call")
            
            // Send SMS
            if (parts.size > 1) {
                // Create PendingIntent array for multipart SMS
                val sentIntents = ArrayList<PendingIntent>().apply {
                    repeat(parts.size) { i ->
                        add(PendingIntent.getBroadcast(reactApplicationContext, i, sentIntent, pendingIntentFlags))
                    }
                }
                smsManager.sendMultipartTextMessage(phoneNumber, null, parts, sentIntents, null)
            } else {
                smsManager.sendTextMessage(phoneNumber, null, smsMessage, sentPI, null)
            }
            
            // Create data for event
            val eventData = Arguments.createMap().apply {
                putString("phoneNumber", phoneNumber)
                putString("message", smsMessage)
                putString("status", "SENT")
                putDouble("timestamp", System.currentTimeMillis().toDouble())
            }
            
            // Emit event
            sendEvent("onSmsSent", eventData)
            
            Log.d(TAG, "SMS sent successfully to missed call from $phoneNumber")
        } catch (e: Exception) {
            Log.e(TAG, "Error sending SMS for missed call: ${e.message}")
            
            // Create data for event
            val eventData = Arguments.createMap().apply {
                putString("phoneNumber", phoneNumber)
                putString("message", DEFAULT_MESSAGE)
                putString("status", "FAILED")
                putString("error", e.message ?: "Unknown error")
                putDouble("timestamp", System.currentTimeMillis().toDouble())
            }
            
            // Emit event
            sendEvent("onSmsError", eventData)
        }
    }

    private fun handleSmsSent(intent: Intent) {
        when (intent.extras?.getInt("resultCode", -1) ?: -1) {
            Activity.RESULT_OK -> {
                Log.d(TAG, "SMS sent successfully")
            }
            SmsManager.RESULT_ERROR_GENERIC_FAILURE -> {
                Log.e(TAG, "Generic failure")
            }
            SmsManager.RESULT_ERROR_NO_SERVICE -> {
                Log.e(TAG, "No service")
            }
            SmsManager.RESULT_ERROR_NULL_PDU -> {
                Log.e(TAG, "Null PDU")
            }
            SmsManager.RESULT_ERROR_RADIO_OFF -> {
                Log.e(TAG, "Radio off")
            }
        }
    }

    private fun handleSmsDelivered(intent: Intent) {
        when (intent.extras?.getInt("resultCode", -1) ?: -1) {
            Activity.RESULT_OK -> {
                Log.d(TAG, "SMS delivered successfully")
            }
            Activity.RESULT_CANCELED -> {
                Log.e(TAG, "SMS not delivered")
            }
        }
    }

    @ReactMethod
    fun getRecentCalls(days: Int, promise: Promise) {
        if (!hasRequiredPermissions()) {
            val missingPermissions = getMissingPermissions()
            Log.e(TAG, "Missing permissions for getting call log: $missingPermissions")
            promise.reject(
                "PERMISSIONS_DENIED", 
                "Cannot access call log: Missing required permissions. Please grant all permissions first."
            )
            return
        }

        try {
            val projection = arrayOf(
                CallLog.Calls.NUMBER,
                CallLog.Calls.TYPE,
                CallLog.Calls.DATE,
                CallLog.Calls.DURATION
            )
            
            val daysAgo = System.currentTimeMillis() - (days * 24 * 60 * 60 * 1000)
            val selection = "${CallLog.Calls.DATE} > ?"
            val selectionArgs = arrayOf(daysAgo.toString())
            val sortOrder = "${CallLog.Calls.DATE} DESC"
            
            val uri = CallLog.Calls.CONTENT_URI
            val cursor = reactApplicationContext.contentResolver.query(
                uri,
                projection,
                selection,
                selectionArgs,
                sortOrder
            )
            
            val calls = Arguments.createArray()
            
            cursor?.use {
                while (it.moveToNext()) {
                    val numberIndex = it.getColumnIndex(CallLog.Calls.NUMBER)
                    val typeIndex = it.getColumnIndex(CallLog.Calls.TYPE)
                    val dateIndex = it.getColumnIndex(CallLog.Calls.DATE)
                    val durationIndex = it.getColumnIndex(CallLog.Calls.DURATION)
                    
                    val call = Arguments.createMap().apply {
                        putString("phoneNumber", it.getString(numberIndex))
                        putInt("type", it.getInt(typeIndex))
                        putDouble("date", it.getLong(dateIndex).toDouble())
                        putInt("duration", it.getInt(durationIndex))
                    }
                    
                    calls.pushMap(call)
                }
            }
            
            promise.resolve(calls)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting recent calls: ${e.message}", e)
            promise.reject("GET_RECENT_CALLS_ERROR", "Failed to get recent calls: ${e.message}")
        }
    }

    @ReactMethod
    fun addListener(eventName: String) {
        // Keep track of listeners if needed
    }

    @ReactMethod
    fun removeListeners(count: Int) {
        // Remove listeners if needed
    }

    private fun sendEvent(eventName: String, params: WritableMap?) {
        reactApplicationContext
            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
            .emit(eventName, params)
    }

    private fun getMissingPermissions(): String {
        val context = reactApplicationContext
        val missingPermissions = mutableListOf<String>()
        
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.READ_CALL_LOG) != PackageManager.PERMISSION_GRANTED) {
            missingPermissions.add("READ_CALL_LOG")
        }
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) {
            missingPermissions.add("READ_PHONE_STATE")
        }
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.SEND_SMS) != PackageManager.PERMISSION_GRANTED) {
            missingPermissions.add("SEND_SMS")
        }
        
        return missingPermissions.joinToString(", ")
    }

    @ReactMethod
    fun getSmsHistoryFromNative(promise: Promise) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            val historyJson = sharedPrefs.getString("@AutoSMS:SmsHistory", "[]") ?: "[]"
            
            // If there's history data, parse it to a WritableArray
            if (historyJson != "[]") {
                try {
                    // Convert JSON string to WritableArray
                    val jsonArray = org.json.JSONArray(historyJson)
                    val resultArray = Arguments.createArray()
                    
                    for (i in 0 until jsonArray.length()) {
                        val jsonObject = jsonArray.getJSONObject(i)
                        val item = Arguments.createMap()
                        
                        // Copy all fields from JSON to WritableMap
                        val keys = jsonObject.keys()
                        while (keys.hasNext()) {
                            val key = keys.next()
                            val value = jsonObject.get(key)
                            
                            when (value) {
                                is String -> item.putString(key, value)
                                is Int -> item.putInt(key, value)
                                is Double -> item.putDouble(key, value)
                                is Long -> item.putDouble(key, value.toDouble())
                                is Boolean -> item.putBoolean(key, value)
                                else -> {
                                    // Handle case when the value is null or another type
                                    if (!jsonObject.isNull(key)) {
                                        item.putString(key, value.toString())
                                    }
                                }
                            }
                        }
                        
                        resultArray.pushMap(item)
                    }
                    
                    // Clear history in SharedPreferences after retrieving it
                    sharedPrefs.edit().putString("@AutoSMS:SmsHistory", "[]").apply()
                    
                    promise.resolve(resultArray)
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing SMS history JSON: ${e.message}", e)
                    promise.reject("PARSE_HISTORY_ERROR", "Failed to parse SMS history: ${e.message}")
                }
            } else {
                // No history, return empty array
                promise.resolve(Arguments.createArray())
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting SMS history: ${e.message}", e)
            promise.reject("GET_HISTORY_ERROR", "Failed to get SMS history: ${e.message}")
        }
    }

    @ReactMethod
    fun isAIEnabled(promise: Promise) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            val enabled = sharedPrefs.getBoolean("@AutoSMS:AIEnabled", false)
            promise.resolve(enabled)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting AI SMS enabled: ${e.message}")
            promise.reject("GET_AI_SMS_ERROR", "Failed to get AI SMS enabled: ${e.message}")
        }
    }

    @ReactMethod
    fun setAIEnabled(enabled: Boolean, promise: Promise) {
        try {
            // Save setting to SharedPreferences for use when app is killed
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            sharedPrefs.edit().putBoolean("@AutoSMS:AIEnabled", enabled).apply()
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "Error setting AI SMS enabled: ${e.message}")
            promise.reject("SET_AI_SMS_ERROR", "Failed to set AI SMS enabled: ${e.message}")
        }
    }
    
    @ReactMethod
    fun getInitialSmsMessage(promise: Promise) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            val message = sharedPrefs.getString("@AutoSMS:InitialMessage", "AI: I am busy, available only for chat. How may I help you?")
            promise.resolve(message)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting initial SMS message: ${e.message}")
            promise.reject("GET_INITIAL_SMS_ERROR", "Failed to get initial SMS message: ${e.message}")
        }
    }
    
    @ReactMethod
    fun setInitialSmsMessage(message: String, promise: Promise) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            sharedPrefs.edit().putString("@AutoSMS:InitialMessage", message).apply()
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "Error setting initial SMS message: ${e.message}")
            promise.reject("SET_INITIAL_SMS_ERROR", "Failed to set initial SMS message: ${e.message}")
        }
    }

    private fun registerSmsReceiver() {
        try {
            // Register for incoming SMS messages
            val smsIntentFilter = IntentFilter()
            smsIntentFilter.addAction(Telephony.Sms.Intents.SMS_RECEIVED_ACTION)
            
            val smsReceiver = object : BroadcastReceiver() {
                override fun onReceive(context: Context, intent: Intent) {
                    if (intent.action == Telephony.Sms.Intents.SMS_RECEIVED_ACTION) {
                        // Check if AI SMS is enabled
                        val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
                        val aiEnabled = sharedPrefs.getBoolean("@AutoSMS:AIEnabled", false)
                        
                        if (!aiEnabled) {
                            Log.d(TAG, "AI SMS is disabled. Ignoring incoming message.")
                            return
                        }
                        
                        // Process incoming SMS
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                            for (smsMessage in Telephony.Sms.Intents.getMessagesFromIntent(intent)) {
                                val phoneNumber = smsMessage.originatingAddress
                                val messageBody = smsMessage.messageBody
                                
                                Log.d(TAG, "Received SMS from $phoneNumber: $messageBody")
                                
                                // Emit event to React Native
                                val eventData = Arguments.createMap().apply {
                                    putString("phoneNumber", phoneNumber)
                                    putString("message", messageBody)
                                    putDouble("timestamp", System.currentTimeMillis().toDouble())
                                }
                                
                                sendEvent("onSmsReceived", eventData)
                            }
                        }
                    }
                }
            }
            
            reactApplicationContext.registerReceiver(smsReceiver, smsIntentFilter)
            Log.d(TAG, "SMS receiver registered successfully")
        } catch (e: Exception) {
            Log.e(TAG, "Error registering SMS receiver: ${e.message}", e)
        }
    }

    @ReactMethod
    fun processPendingMessages(promise: Promise) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            val pendingMessages = sharedPrefs.getStringSet("pendingIncomingSms", HashSet()) ?: HashSet()
            
            if (pendingMessages.isEmpty()) {
                promise.resolve(false)
                return
            }
            
            Log.d(TAG, "Processing ${pendingMessages.size} pending SMS messages")
            
            for (pendingMessage in pendingMessages) {
                try {
                    val parts = pendingMessage.split(":", limit = 3)
                    if (parts.size == 3) {
                        val phoneNumber = parts[0]
                        val message = parts[1]
                        
                        // Emit event to React Native
                        val eventData = Arguments.createMap().apply {
                            putString("phoneNumber", phoneNumber)
                            putString("message", message)
                            putDouble("timestamp", System.currentTimeMillis().toDouble())
                        }
                        
                        sendEvent("onSmsReceived", eventData)
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error processing pending message: ${e.message}")
                }
            }
            
            // Clear pending messages
            sharedPrefs.edit().putStringSet("pendingIncomingSms", HashSet()).apply()
            
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "Error processing pending messages: ${e.message}")
            promise.reject("PROCESS_PENDING_ERROR", "Failed to process pending messages: ${e.message}")
        }
    }

    /**
     * Process incoming SMS and generate response using local LLM if available, 
     * or fallback to online API
     */
    private fun processIncomingSmsWithLLM(caller: String, messageBody: String): String {
        try {
            // Check if Local LLM module is loaded
            val localLLMModule = reactApplicationContext.getNativeModule(com.auto_sms.llm.LocalLLMModule::class.java)
            
            if (localLLMModule != null) {
                // Try to generate response with local LLM
                try {
                    val isLoaded = localLLMModule.isModelLoadedSync()
                    
                    if (isLoaded) {
                        Log.d(TAG, "Using local LLM for response generation")
                        val response = localLLMModule.generateAnswerSync(messageBody, 0.7f, 200)
                        
                        // Ensure response starts with "AI:" prefix
                        return if (response.startsWith("AI:")) {
                            response
                        } else {
                            "AI: $response"
                        }
                    } else {
                        Log.d(TAG, "Local LLM model is not loaded, falling back to online API")
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error using local LLM for response: ${e.message}")
                }
            }
            
            // Fallback to online AI API response
            return generateAIResponseSync(caller, messageBody)
        } catch (e: Exception) {
            Log.e(TAG, "Error in processIncomingSmsWithLLM: ${e.message}")
            return "AI: Sorry, I am not capable of giving this answer. Wait for a call or try with a different question."
        }
    }
    
    /**
     * Fallback method for generating AI responses when LLM is not available
     */
    private fun generateAIResponseSync(caller: String, message: String): String {
        // Simple fallback response when local LLM is not available
        return "AI: Sorry, I am not capable of giving this answer. Wait for a call or try with a different question."
    }

    @ReactMethod
    fun checkLLMStatus(promise: Promise) {
        try {
            Log.d(TAG, "🔍 DIAGNOSTIC - Running LLM status check")
            
            val diagnosticReport = Arguments.createMap()
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            
            // Check enabled settings
            val autoReplyEnabled = sharedPrefs.getBoolean("@AutoSMS:AutoReplyEnabled", false)
            val llmAutoReplyEnabled = sharedPrefs.getBoolean("@AutoSMS:LLMAutoReplyEnabled", false)
            val aiEnabled = sharedPrefs.getBoolean("@AutoSMS:AIEnabled", false)
            
            diagnosticReport.putBoolean("simpleAutoReplyEnabled", autoReplyEnabled)
            diagnosticReport.putBoolean("llmAutoReplyEnabled", llmAutoReplyEnabled)
            diagnosticReport.putBoolean("aiEnabled", aiEnabled)
            
            // Check documents directory
            val documentsDir = File(reactApplicationContext.filesDir, "documents")
            val exists = documentsDir.exists()
            diagnosticReport.putBoolean("documentsDirectoryExists", exists)
            
            if (exists) {
                val documentFiles = documentsDir.listFiles()
                val documentsArray = Arguments.createArray()
                
                if (documentFiles != null && documentFiles.isNotEmpty()) {
                    for (file in documentFiles) {
                        val docMap = Arguments.createMap()
                        docMap.putString("name", file.name)
                        docMap.putDouble("size", file.length().toDouble())
                        docMap.putDouble("lastModified", file.lastModified().toDouble())
                        documentsArray.pushMap(docMap)
                    }
                }
                
                diagnosticReport.putArray("documents", documentsArray)
                diagnosticReport.putInt("documentCount", documentFiles?.size ?: 0)
            } else {
                diagnosticReport.putInt("documentCount", 0)
            }
            
            // Check if the LLM module is available
            try {
                val reactContext = reactApplicationContext
                val llmModule = reactContext.getNativeModule(com.auto_sms.llm.LocalLLMModule::class.java)
                val isAvailable = llmModule != null
                diagnosticReport.putBoolean("llmModuleAvailable", isAvailable)
                
                if (isAvailable) {
                    // Check if a model is loaded
                    val isModelLoaded = llmModule!!.isModelLoadedSync()
                    diagnosticReport.putBoolean("modelLoaded", isModelLoaded)
                    
                    // Try a test generation if model is loaded
                    if (isModelLoaded) {
                        val testQuestion = "Hello, is the LLM working?"
                        val response = llmModule.generateAnswerSync(testQuestion, 0.7f, 100)
                        diagnosticReport.putString("testResponse", response)
                        diagnosticReport.putBoolean("testPassed", response != null && response.isNotEmpty())
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error accessing LLM module", e)
                diagnosticReport.putBoolean("llmModuleAvailable", false)
                diagnosticReport.putString("llmError", e.message)
            }
            
            // Return the diagnostic report
            promise.resolve(diagnosticReport)
            
            // Also log the report
            Log.d(TAG, "📊 LLM DIAGNOSTIC REPORT: $diagnosticReport")
        } catch (e: Exception) {
            Log.e(TAG, "Error checking LLM status", e)
            promise.reject("CHECK_LLM_ERROR", "Failed to check LLM status: ${e.message}")
        }
    }

    /**
     * Set LLM auto-reply enabled state
     */
    @ReactMethod
    fun setLLMAutoReplyEnabled(enabled: Boolean, promise: Promise) {
        try {
            Log.d(TAG, "🤖 Setting LLM auto-reply enabled: $enabled")
            
            // Save setting to SharedPreferences for use when app is killed
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            sharedPrefs.edit().putBoolean("@AutoSMS:LLMAutoReplyEnabled", enabled).apply()
            
            // Log the current state of all auto-reply settings for debugging
            val autoReplyEnabled = sharedPrefs.getBoolean("@AutoSMS:AutoReplyEnabled", false)
            val aiEnabled = sharedPrefs.getBoolean("@AutoSMS:AIEnabled", false)
            Log.d(TAG, "📊 Auto-reply settings after update:")
            Log.d(TAG, "   • Simple Auto-Reply: $autoReplyEnabled")
            Log.d(TAG, "   • LLM Auto-Reply: $enabled")
            Log.d(TAG, "   • AI Enabled: $aiEnabled")
            
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error setting LLM auto-reply enabled: ${e.message}")
            promise.reject("SET_LLM_AUTO_REPLY_ERROR", "Failed to set LLM auto-reply enabled: ${e.message}")
        }
    }
    
    /**
     * Check if LLM auto-reply is enabled
     */
    @ReactMethod
    fun isLLMAutoReplyEnabled(promise: Promise) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            val enabled = sharedPrefs.getBoolean("@AutoSMS:LLMAutoReplyEnabled", false)
            Log.d(TAG, "🤖 LLM auto-reply enabled status: $enabled")
            promise.resolve(enabled)
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error checking if LLM auto-reply is enabled: ${e.message}")
            promise.reject("GET_LLM_AUTO_REPLY_ERROR", "Failed to get LLM auto-reply enabled: ${e.message}")
        }
    }

    /**
     * Set simple auto-reply enabled state directly
     */
    @ReactMethod
    fun setAutoReplyEnabled(enabled: Boolean, promise: Promise) {
        try {
            Log.e(TAG, "🔧 Setting auto reply enabled: $enabled")
            // Save setting to SharedPreferences for use when app is killed
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            sharedPrefs.edit().putBoolean("@AutoSMS:AutoReplyEnabled", enabled).apply()
            
            // Log the update for verification
            Log.e(TAG, "✅ Auto reply enabled set to: $enabled")
            Log.e(TAG, "📊 Current SharedPrefs values:")
            Log.e(TAG, "   • Auto-Reply: ${sharedPrefs.getBoolean("@AutoSMS:AutoReplyEnabled", false)}")
            Log.e(TAG, "   • LLM Auto-Reply: ${sharedPrefs.getBoolean("@AutoSMS:LLMAutoReplyEnabled", false)}")
            
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error setting auto reply enabled: ${e.message}")
            promise.reject("SET_AUTO_REPLY_ERROR", "Failed to set auto reply enabled: ${e.message}")
        }
    }

    /**
     * Check if simple auto-reply is enabled
     */
    @ReactMethod
    fun isAutoReplyEnabled(promise: Promise) {
        try {
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            val enabled = sharedPrefs.getBoolean("@AutoSMS:AutoReplyEnabled", false)
            
            // Log for debugging
            Log.e(TAG, "🔍 Checking auto-reply enabled status: $enabled")
            
            promise.resolve(enabled)
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error checking auto reply enabled: ${e.message}")
            promise.reject("GET_AUTO_REPLY_ERROR", "Failed to check auto reply enabled: ${e.message}")
        }
    }
    
    /**
     * Add a test phone number to the missed call numbers list
     */
    @ReactMethod
    fun addTestPhoneNumber(phoneNumber: String, promise: Promise) {
        try {
            Log.e(TAG, "📞 Adding test phone number to missed call list: $phoneNumber")
            
            val sharedPrefs = reactApplicationContext.getSharedPreferences("AutoSmsPrefs", Context.MODE_PRIVATE)
            val missedCallNumbers = sharedPrefs.getStringSet("missedCallNumbers", HashSet()) ?: HashSet()
            
            // Add the test entry with current timestamp
            val newMissedCallNumbers = HashSet(missedCallNumbers)
            val timestamp = System.currentTimeMillis()
            newMissedCallNumbers.add("$phoneNumber:$timestamp")
            
            // Save back to SharedPreferences
            sharedPrefs.edit().putStringSet("missedCallNumbers", newMissedCallNumbers).apply()
            
            // Verify by reading back
            val updatedSet = sharedPrefs.getStringSet("missedCallNumbers", HashSet()) ?: HashSet()
            Log.e(TAG, "✅ Test phone number added. Currently ${updatedSet.size} entries:")
            for (entry in updatedSet) {
                Log.e(TAG, "   • $entry")
            }
            
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error adding test phone number: ${e.message}")
            promise.reject("ADD_TEST_NUMBER_ERROR", "Failed to add test phone number: ${e.message}")
        }
    }
    
    /**
     * Send a test SMS for debugging
     */
    @ReactMethod
    fun sendTestSms(phoneNumber: String, message: String, promise: Promise) {
        try {
            Log.e(TAG, "🧪 Sending test SMS to $phoneNumber: $message")
            
            val smsManager = SmsManager.getDefault()
            
            // Add FLAG_IMMUTABLE for Android 12+ compatibility
            val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            } else {
                PendingIntent.FLAG_UPDATE_CURRENT
            }
            
            // Prepare PendingIntent for SMS
            val sentIntent = Intent("android.provider.Telephony.SMS_SENT")
            val sentPI = PendingIntent.getBroadcast(reactApplicationContext, 0, sentIntent, pendingIntentFlags)
            
            // Split message if it's too long
            val parts = smsManager.divideMessage(message)
            
            try {
                // Send SMS
                if (parts.size > 1) {
                    // Create PendingIntent array for multipart SMS
                    val sentIntents = ArrayList<PendingIntent>().apply {
                        repeat(parts.size) { i ->
                            add(PendingIntent.getBroadcast(reactApplicationContext, i, sentIntent, pendingIntentFlags))
                        }
                    }
                    
                    Log.e(TAG, "📤 Sending multipart test SMS")
                    smsManager.sendMultipartTextMessage(phoneNumber, null, parts, sentIntents, null)
                    Log.e(TAG, "✅ Sent multipart test SMS successfully")
                } else {
                    Log.e(TAG, "📤 Sending single part test SMS")
                    smsManager.sendTextMessage(phoneNumber, null, message, sentPI, null)
                    Log.e(TAG, "✅ Sent single test SMS successfully")
                }
                
                promise.resolve(true)
            } catch (e: Exception) {
                Log.e(TAG, "❌ Error sending test SMS: ${e.message}")
                e.printStackTrace()
                promise.reject("SEND_TEST_SMS_ERROR", "Failed to send test SMS: ${e.message}")
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error in sendTestSms: ${e.message}")
            promise.reject("SEND_TEST_SMS_ERROR", "Failed to send test SMS: ${e.message}")
        }
    }

    /**
     * Test the LLM by generating a response to a question
     * This is used by the LLM testing UI in the app
     */
    @ReactMethod
    fun testLLM(question: String, promise: Promise) {
        try {
            Log.e(TAG, "🧪 Testing LLM with question: $question")
            
            // Record start time for performance measurement
            val startTime = System.currentTimeMillis()
            
            // Create an instance of SmsReceiver to use its generateLLMResponse method
            val smsReceiver = SmsReceiver()
            
            // Check if we should load document content for better context
            val documentsDir = File(reactApplicationContext.filesDir, "documents")
            if (documentsDir.exists()) {
                val documents = documentsDir.listFiles()
                if (documents != null && documents.isNotEmpty()) {
                    Log.e(TAG, "📑 Found ${documents.size} documents to process")
                    
                    // Load document content into memory for LLM context
                    val documentContentMap = mutableMapOf<String, String>()
                    var totalSize = 0L
                    
                    for (document in documents) {
                        try {
                            if (document.isFile) {
                                val name = document.name
                                val size = document.length()
                                totalSize += size
                                
                                // Process based on file type
                                val content = when {
                                    // PDF files
                                    document.name.lowercase().endsWith(".pdf") -> extractTextFromPdf(document)
                                    
                                    // DOCX files
                                    document.name.lowercase().endsWith(".docx") -> extractTextFromDocx(document)
                                    
                                    // Plain text files
                                    document.name.lowercase().endsWith(".txt") || 
                                    document.name.lowercase().endsWith(".md") ||
                                    document.name.lowercase().endsWith(".csv") -> document.readText()
                                    
                                    // Skip other file types
                                    else -> null
                                }
                                
                                documentContentMap[name] = content
                                Log.e(TAG, "✅ Processed document: $name (${size/1024} KB)")
                            }
                        } catch (e: Exception) {
                            Log.e(TAG, "❌ Error loading document ${document.name}", e)
                            documentContentMap[document.name] = "[Error: Could not read file]"
                        }
                    }
                    
                    Log.e(TAG, "📊 Loaded ${documentContentMap.size}/${documents.size} documents, total ${totalSize/1024} KB")
                    
                    // Now enhance the question with document snippets
                    val enhancedQuestion = buildEnhancedPrompt(question, documentContentMap)
                    
                    // Generate response using the enhanced prompt
                    val response = smsReceiver.generateLLMResponse(reactApplicationContext, enhancedQuestion)
                    
                    val endTime = System.currentTimeMillis()
                    Log.e(TAG, "⏱️ LLM test took ${endTime - startTime}ms")
                    
                    if (response != null) {
                        Log.e(TAG, "✅ LLM test successful, response: $response")
                        promise.resolve(response)
                    } else {
                        Log.e(TAG, "❌ LLM test failed, null response")
                        promise.reject("LLM_TEST_ERROR", "LLM test failed, null response")
                    }
                    return
                }
            }
            
            // Fall back to basic question if no documents available
            Log.e(TAG, "📝 No documents found, using basic question")
            
            // Generate response using the same method used for SMS replies
            val response = smsReceiver.generateLLMResponse(reactApplicationContext, question)
            
            val endTime = System.currentTimeMillis()
            Log.e(TAG, "⏱️ LLM test took ${endTime - startTime}ms")
            
            if (response != null) {
                Log.e(TAG, "✅ LLM test successful, response: $response")
                promise.resolve(response)
            } else {
                Log.e(TAG, "❌ LLM test failed, null response")
                promise.reject("LLM_TEST_ERROR", "LLM test failed, null response")
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error testing LLM: ${e.message}", e)
            promise.reject("LLM_TEST_ERROR", "Error testing LLM: ${e.message}")
        }
    }
    
    /**
     * Build an enhanced prompt that includes document content for the LLM
     */
    private fun buildEnhancedPrompt(question: String, documents: Map<String, String>): String {
        val sb = StringBuilder()
        sb.append("Using the following documents as reference:\n\n")
        
        // Add document content (limit to keep prompt manageable)
        var documentCount = 0
        for ((name, content) in documents) {
            if (documentCount >= 5) {
                sb.append("... (${documents.size - 5} more documents available)\n\n")
                break
            }
            
            sb.append("DOCUMENT: $name\n")
            
            // Check if this is a binary/PDF file content that needs sanitizing
            val displayContent = if (isProbablyBinaryContent(content, name)) {
                // For binary content, extract text or return placeholder
                extractTextFromBinaryContent(name, content)
            } else if (content.length > 1000) {
                // Limit text document content to 1000 chars
                content.substring(0, 1000) + "... (truncated)"
            } else {
                content
            }
            
            sb.append("CONTENT:\n$displayContent\n\n")
            documentCount++
        }
        
        // Add the question
        sb.append("QUESTION: $question\n\n")
        sb.append("Please answer the question using only information from the provided documents. If the documents don't contain relevant information, say so.")
        
        return sb.toString()
    }
    
    /**
     * Check if content appears to be binary/non-text data
     */
    private fun isProbablyBinaryContent(content: String, filename: String = ""): Boolean {
        if (content.isEmpty()) return false
        
        // Check for PDF signature
        if (content.startsWith("%PDF")) return true
        
        // Check filename extension if provided
        if (filename.isNotEmpty()) {
            val lowerFilename = filename.lowercase()
            if (lowerFilename.endsWith(".pdf") || lowerFilename.endsWith(".docx") || 
                lowerFilename.endsWith(".jpg") || lowerFilename.endsWith(".jpeg") || 
                lowerFilename.endsWith(".png") || lowerFilename.endsWith(".gif")) {
                return true
            }
        }
        
        // Check for high concentration of non-printable characters
        val sampleSize = Math.min(content.length, 500)
        val sample = content.substring(0, sampleSize)
        val nonPrintableCount = sample.count { char ->
            char.toInt() < 32 && char.toInt() != 9 && char.toInt() != 10 && char.toInt() != 13
        }
        
        // If more than 15% of characters are non-printable, consider it binary
        return (nonPrintableCount.toFloat() / sampleSize) > 0.15
    }
    
    /**
     * Extract meaningful text from binary content based on file type
     */
    private fun extractTextFromBinaryContent(filename: String, content: String): String {
        // Check file extension
        val lowerFilename = filename.lowercase()
        
        return when {
            lowerFilename.endsWith(".pdf") -> {
                "This is a PDF document. Please use the 'extractTextFromPdf' method to process it properly."
            }
            lowerFilename.endsWith(".docx") -> {
                "This is a Word document. Please use appropriate document processing library to extract text."
            }
            lowerFilename.endsWith(".jpg") || lowerFilename.endsWith(".jpeg") || 
            lowerFilename.endsWith(".png") || lowerFilename.endsWith(".gif") -> {
                "This is an image file. Text extraction from images requires OCR processing."
            }
            else -> {
                "[Binary content detected - cannot display readable text]"
            }
        }
    }

    /**
     * Extract text from a DOCX file
     */
    private fun extractTextFromDocx(file: File): String {
        try {
            Log.d(TAG, "📄 Extracting text from DOCX: ${file.name}")
            val inputStream = FileInputStream(file)

            try {
                // First try using XWPFWordExtractor which is more robust
                try {
                    Log.d(TAG, "🔍 Using XWPFWordExtractor for DOCX extraction")
                    val document = XWPFDocument(inputStream)
                    val extractor = XWPFWordExtractor(document)
                    val text = extractor.text
                    
                    // Close resources
                    extractor.close()
                    document.close()
                    
                    if (text.isNotEmpty()) {
                        Log.d(TAG, "✅ Successfully extracted ${text.length} chars from DOCX")
                        return text
                    } else {
                        Log.d(TAG, "⚠️ XWPFWordExtractor returned empty text, trying fallback method")
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "❌ XWPFWordExtractor failed: ${e.message}")
                    // Continue to fallback method
                }
                
                // Reset the input stream for the fallback method
                inputStream.close()
                val newInputStream = FileInputStream(file)
                
                // Try the manual extraction approach
                val doc = XWPFDocument(newInputStream)
                val textBuilder = StringBuilder()
                
                // Extract paragraphs
                for (paragraph in doc.paragraphs) {
                    textBuilder.append(paragraph.text)
                    textBuilder.append("\n")
                }
                
                // Extract tables
                for (table in doc.tables) {
                    for (row in table.rows) {
                        for (cell in row.tableCells) {
                            for (paragraph in cell.paragraphs) {
                                textBuilder.append(paragraph.text)
                                textBuilder.append(" ")
                            }
                            textBuilder.append(" | ")
                        }
                        textBuilder.append("\n")
                    }
                    textBuilder.append("\n")
                }
                
                doc.close()
                
                val result = textBuilder.toString()
                if (result.isNotEmpty()) {
                    Log.d(TAG, "✅ Successfully extracted ${result.length} chars from DOCX using manual method")
                    return result
                } else {
                    Log.e(TAG, "⚠️ Manual extraction returned empty text, falling back to simple extraction")
                    return simpleExtractTextFromDocx(file)
                }
            } catch (e: Exception) {
                Log.e(TAG, "❌ Error in DOCX extraction: ${e.message}")
                return simpleExtractTextFromDocx(file)
            } finally {
                try {
                    inputStream.close()
                } catch (e: Exception) {
                    Log.e(TAG, "❌ Error closing input stream: ${e.message}")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error in DOCX extraction: ${e.message}")
            return simpleExtractTextFromDocx(file)
        }
    }

    /**
     * Simple fallback method for DOCX extraction when POI fails
     */
    private fun simpleExtractTextFromDocx(file: File): String {
        try {
            // Attempt a simpler extraction approach that doesn't use complex POI features
            // This is a fallback that tries to read the document.xml directly
            
            Log.d(TAG, "📝 Using simple DOCX extraction fallback")
            
            // Read the DOCX binary data
            val bytes = file.readBytes()
            
            // For Word files, try to return a helpful message
            val docName = file.name
            
            // Try to guess content from filename
            val contentGuess = when {
                docName.contains("treatment", true) -> 
                    "This appears to be a document about medical treatments."
                docName.contains("patient", true) -> 
                    "This appears to be a patient-related document."
                docName.contains("report", true) -> 
                    "This appears to be a report document."
                else -> 
                    "This is a Word document that may contain important information related to your query."
            }
            
            return "DOCX CONTENT (extracted with simple method): $contentGuess\n" +
                   "Document name: $docName\n" +
                   "File size: ${bytes.size} bytes"
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error in simple DOCX extraction: ${e.message}")
            return "[DOCX extraction failed: ${e.message}]"
        }
    }

    /**
     * Data class for a document passage
     */
    data class Passage(
        val documentName: String,
        val text: String,
        val index: Int,
        var score: Float = 0f
    )
    
    /**
     * Split documents into passages for more focused retrieval
     */
    private fun createPassagesFromDocuments(documents: Map<String, String>): List<Passage> {
        val passages = mutableListOf<Passage>()
        
        documents.forEach { (documentName, content) ->
            // Split content by paragraphs
            val paragraphs = content.split(Regex("\n{2,}"))
            
            // Group paragraphs into reasonably-sized passages
            val passageSize = 2000  // Characters per passage
            
            val currentPassage = StringBuilder()
            var passageCount = 0
            
            for (paragraph in paragraphs) {
                // If adding this paragraph would exceed our target size, create a new passage
                if (currentPassage.length + paragraph.length > passageSize && currentPassage.isNotEmpty()) {
                    passages.add(Passage(documentName, currentPassage.toString().trim(), passageCount++))
                    currentPassage.clear()
                }
                
                // Add the paragraph to the current passage
                currentPassage.append(paragraph)
                currentPassage.append("\n\n")
            }
            
            // Add the last passage if it has content
            if (currentPassage.isNotEmpty()) {
                passages.add(Passage(documentName, currentPassage.toString().trim(), passageCount))
            }
        }
        
        return passages
    }
    
    /**
     * Retrieve passages most relevant to the query
     */
    private fun retrieveRelevantPassages(query: String, passages: List<Passage>, maxResults: Int): List<Passage> {
        // Prepare query terms
        val queryTerms = tokenizeAndNormalize(query)
        
        // Score each passage based on term overlap and TF-IDF principles
        for (passage in passages) {
            val passageTerms = tokenizeAndNormalize(passage.text)
            
            val commonTermCount = queryTerms.intersect(passageTerms).size
            val termRatio = if (passageTerms.isEmpty()) 0f else commonTermCount.toFloat() / passageTerms.size
            val queryRatio = if (queryTerms.isEmpty()) 0f else commonTermCount.toFloat() / queryTerms.size
            
            // Score is weighted between query coverage and term density
            passage.score = (queryRatio * 0.7f) + (termRatio * 0.3f)
            
            // Bonus for exact phrase matches
            if (passage.text.contains(query, ignoreCase = true)) {
                passage.score += 0.3f
            }
            
            // Bonus for title matches (assuming document names might be titles)
            if (passage.documentName.contains(query, ignoreCase = true)) {
                passage.score += 0.2f
            }
        }
        
        // Return top-scoring passages
        return passages.sortedByDescending { it.score }.take(maxResults)
    }
    
    /**
     * Tokenize and normalize text for comparison
     */
    private fun tokenizeAndNormalize(text: String): Set<String> {
        // Remove punctuation, lowercase, and split by whitespace
        val normalized = text.lowercase()
            .replace(Regex("[^a-z0-9\\s]"), " ")
            .replace(Regex("\\s+"), " ")
            .trim()
        
        // Split into words and filter stopwords
        val words = normalized.split(" ")
        
        return words.filter { 
            it.length > 2 && !STOPWORDS.contains(it) 
        }.toSet()
    }
    
    /**
     * Common English stopwords to filter out
     */
    private val STOPWORDS = setOf(
        "the", "and", "that", "for", "with", "this", "from", "have", "are", "you", 
        "not", "was", "were", "they", "will", "what", "when", "how", "where", "which", 
        "who", "whom", "whose", "why", "can", "could", "should", "would", "may", "might",
        "must", "their", "them", "these", "those", "there", "here", "over", "under", "above"
    )
    
    /**
     * Build a QA prompt with retrieved passages for the LLM
     */
    private fun buildQAPrompt(question: String, passages: List<Passage>): String {
        val prompt = StringBuilder()
        
        // Instruction for the LLM
        prompt.append("You are an AI assistant answering questions based on the user's documents.\n\n")
        
        // Add context from retrieved passages
        prompt.append("Here are relevant passages from the documents:\n\n")
        
        passages.forEach { passage ->
            prompt.append("--- From document: ${passage.documentName} ---\n")
            prompt.append(passage.text)
            prompt.append("\n\n")
        }
        
        // Add the question and instructions
        prompt.append("Based on the above information, please answer this question:\n")
        prompt.append(question)
        prompt.append("\n\n")
        
        // Add response formatting instructions
        prompt.append("If you cannot find an answer in the provided passages, say so clearly. ")
        prompt.append("Answer concisely but include all relevant information. ")
        prompt.append("Start your answer with 'AI: '")
        
        return prompt.toString()
    }

    /**
     * Enhanced version of testLLM that performs document retrieval for better context
     * This implements a full Q&A pipeline with document retrieval
     * With improved security handling to prevent AccessController errors
     */
    @ReactMethod
    fun documentQA(question: String, maxResults: Int, promise: Promise) {
        try {
            Log.d(TAG, "📝 Document Q&A request: '$question', max results: $maxResults")
            
            // 1. Extract text from all available documents - in a safer way
            val documentsWithText = safeExtractTextFromAllDocuments()
            
            if (documentsWithText.isEmpty()) {
                Log.e(TAG, "❌ No documents available for Q&A")
                promise.resolve("AI: I'm sorry, I couldn't find any documents to help answer your question.")
                return
            }
            
            Log.d(TAG, "✅ Extracted text from ${documentsWithText.size} documents")
            
            // 2. Split documents into passages (chunks) - no security issues here
            val passages = createPassagesFromDocuments(documentsWithText)
            Log.d(TAG, "✅ Created ${passages.size} passages from documents")
            
            // 3. Retrieve most relevant passages for the query - no security issues here
            val retrievedPassages = retrieveRelevantPassages(question, passages, maxResults.coerceIn(1, 10))
            Log.d(TAG, "✅ Retrieved ${retrievedPassages.size} relevant passages")
            
            // 4. Build a prompt with the question and retrieved passages - no security issues here
            val prompt = buildQAPrompt(question, retrievedPassages)
            Log.d(TAG, "✅ Built QA prompt with ${prompt.length} characters")
            
            // 5. Generate answer using our normal LLM method
            val answer = generateLLMResponse(prompt)
            
            // 6. Format and return the answer
            if (answer != null) {
                // Make sure the answer starts with "AI: "
                val formattedAnswer = if (!answer.startsWith("AI:")) "AI: $answer" else answer
                promise.resolve(formattedAnswer)
            } else {
                // Fallback for failed LLM response
                promise.resolve("AI: I'm sorry, I couldn't find information about this in your documents. Please try asking a different question.")
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error in document Q&A: ${e.message}", e)
            promise.resolve("AI: Sorry, I'm not available right now due to a technical issue.")
        }
    }

    /**
     * Extract text from all available documents with improved security handling
     */
    private fun safeExtractTextFromAllDocuments(): Map<String, String> {
        val result = mutableMapOf<String, String>()
        val documentsDir = File(reactApplicationContext.filesDir, "documents")
        
        if (!documentsDir.exists() || !documentsDir.isDirectory) {
            Log.e(TAG, "❌ Documents directory doesn't exist")
            return result
        }
        
        val files = documentsDir.listFiles() ?: return result
        
        for (file in files) {
            if (!file.isFile) continue
            
            try {
                val text = when {
                    // PDF files - using PDFBox instead of iText for better security
                    file.name.lowercase().endsWith(".pdf") -> safeExtractTextFromPdf(file)
                    
                    // DOCX files - using our improved method
                    file.name.lowercase().endsWith(".docx") -> extractTextFromDocx(file)
                    
                    // Plain text files
                    file.name.lowercase().endsWith(".txt") || 
                    file.name.lowercase().endsWith(".md") ||
                    file.name.lowercase().endsWith(".csv") -> file.readText()
                    
                    // Skip other file types
                    else -> null
                }
                
                if (!text.isNullOrBlank()) {
                    result[file.name] = text
                    Log.d(TAG, "✅ Extracted ${text.length} chars from ${file.name}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "❌ Failed to extract text from ${file.name}: ${e.message}")
            }
        }
        
        return result
    }

    /**
     * Extract text from a PDF file using PDFBox instead of iText
     */
    private fun safeExtractTextFromPdf(file: File): String {
        try {
            // Use PDFBox which has fewer security issues than iText
            val document = PDDocument.load(file)
            val stripper = PDFTextStripper()
            stripper.startPage = 1
            
            // Limit to a reasonable number of pages
            val maxPages = Math.min(document.numberOfPages, 50)
            stripper.endPage = maxPages
            
            val text = stripper.getText(document)
            document.close()
            
            return if (text.isNotEmpty()) {
                // Add page count information
                if (document.numberOfPages > maxPages) {
                    text + "\n\n(PDF has ${document.numberOfPages - maxPages} more pages that were not included)"
                } else {
                    text
                }
            } else {
                "[PDF contains no extractable text]"
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error extracting text from PDF with PDFBox: ${e.message}")
            
            // Try fallback to older iText method
            try {
                val reader = com.itextpdf.text.pdf.PdfReader(file.absolutePath)
                val pages = reader.numberOfPages
                val textBuilder = StringBuilder()
                
                // Extract from all pages (with a reasonable limit)
                val maxPages = Math.min(pages, 20)
                for (i in 1..maxPages) {
                    try {
                        val pageText = com.itextpdf.text.pdf.parser.PdfTextExtractor.getTextFromPage(reader, i)
                        if (pageText.isNotEmpty()) {
                            textBuilder.append("--- Page $i ---\n")
                            textBuilder.append(pageText)
                            textBuilder.append("\n\n")
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "⚠️ Error extracting text from page $i: ${e.message}")
                    }
                }
                
                reader.close()
                return textBuilder.toString()
            } catch (e2: Exception) {
                Log.e(TAG, "❌ Both PDF extraction methods failed: ${e2.message}")
                return "[PDF extraction failed: ${e.message}]"
            }
        }
    }

    /**
     * Generate LLM response directly
     */
    private fun generateLLMResponse(prompt: String): String? {
        try {
            // Use SmsReceiver's implementation but in a direct way
            val smsReceiver = SmsReceiver()
            return smsReceiver.generateLLMResponse(reactApplicationContext, prompt)
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error generating LLM response: ${e.message}")
            return "AI: I encountered an issue processing your request. Please try again later."
        }
    }
} 